from django.db import models
from recipes.models import Recipe
from collections import defaultdict
from typing import List, Dict


class DayPlan(models.Model):
    name = models.CharField(default="autogenerated", max_length=100)
    breakfast = models.ForeignKey(Recipe, related_name='receipt_component_breakfast', on_delete=models.CASCADE,
                                  default=None)
    lunch = models.ForeignKey(Recipe, related_name='receipt_component_lunch', on_delete=models.CASCADE, default=None)
    dinner = models.ForeignKey(Recipe, related_name='receipt_component_dinner', on_delete=models.CASCADE, default=None)

    def get_shop_list_divided_by_meal(self):
        shop_list_by_meals = defaultdict(list)
        for meal_name, meal in [("breakfast", self.breakfast), ('lunch', self.lunch), ("dinner", self.dinner)]:
            ingredients = []
            for receipt_component in meal.recipeingredient_set.all():
                ingredient_details = {
                    "name": receipt_component.component.name,
                    "measurement": receipt_component.measurement,
                    "quantity": receipt_component.quantity}
                ingredients.append(ingredient_details)
            shop_list_by_meals.update({meal_name: ingredients})
        return shop_list_by_meals

    def get_shop_list_divided_by_ingredients(self):
        shop_list_by_ingredient = defaultdict(list)
        day_ingredients = self.get_all_ingredients_details()
        from itertools import groupby
        for k, v in groupby(sorted(day_ingredients,
                                   key=lambda x: x['name']), key=lambda x: x['name']):
            for measurement, ingr in groupby(sorted(v, key=lambda x: x['measurement']),
                                             key=lambda x: x['measurement']):
                quantity_with_type = [(item['quantity'], item["type"]) for item in ingr]
                quantity = sum(x[0] for x in quantity_with_type)
                previous = shop_list_by_ingredient[quantity_with_type[0][1]]
                type_ingredient = [{"name": k, "measurement": measurement, "quantity": quantity}]
                if previous:
                    type_ingredient.extend(previous)
                shop_list_by_ingredient[quantity_with_type[0][1]] = type_ingredient

        return shop_list_by_ingredient

    def get_shop_list(self):
        shop_list = []
        for ingredient in self.get_all_ingredients_details():
            if self.if_ingredient_with_measurement_exist(ingredient, shop_list):
                new_shop_list = self.get_updated_shop_list(ingredient, shop_list)
                ## currently I have no idea how do it better
                shop_list = new_shop_list
            else:
                shop_list.append(ingredient)
        sorted_shop_list = sorted(shop_list, key=lambda k: k['name'])
        return sorted_shop_list

    def get_updated_shop_list(self, checked, shop_list: List[Dict]):
        new_shop_list = []
        for i in shop_list:
            if i["name"] == checked["name"] and i["measurement"] == checked["measurement"]:
                new_quantity = checked["quantity"] + i["quantity"]
                new_shop_list.append(
                    {"name": i["name"], "measurement": i["measurement"], "quantity": new_quantity})
            else:
                new_shop_list.append(i)
        return new_shop_list

    def if_ingredient_with_measurement_exist(self, checked, shop_list: List[Dict]):
        for i in shop_list:
            if i["name"] == checked["name"] and i["measurement"] == checked["measurement"]:
                return True
        return False

    def get_all_ingredients_details(self):
        for meal in (self.breakfast, self.lunch, self.dinner):
            for receipt_component in meal.recipeingredient_set.all():
                yield {
                    "name": receipt_component.component.name,
                    "measurement": receipt_component.measurement,
                    "quantity": receipt_component.quantity,
                    "type": receipt_component.component.types[0]}

    def __str__(self):
        return f"{self.name}: {self.breakfast.name} AND {self.lunch.name} AND {self.dinner.name}"


class WeeklyPlan(models.Model):
    DIET = [
        ("AIP", "AIP"),
        ("NORMAL", "NORMAL")
    ]
    diet_name = models.CharField(max_length=6, choices=DIET, default="AIP")
    monday = models.ForeignKey(DayPlan, related_name='monday_plan', on_delete=models.CASCADE, default=None)
    tuesday = models.ForeignKey(DayPlan, related_name='tuesday_plan', on_delete=models.CASCADE, default=None)
    wednesday = models.ForeignKey(DayPlan, related_name='wednesday_plan', on_delete=models.CASCADE, default=None)
    thursday = models.ForeignKey(DayPlan, related_name='thursday_plan', on_delete=models.CASCADE, default=None)
    friday = models.ForeignKey(DayPlan, related_name='friday_plan', on_delete=models.CASCADE, default=None)
    saturday = models.ForeignKey(DayPlan, related_name='saturday_plan', on_delete=models.CASCADE, default=None)
    sunday = models.ForeignKey(DayPlan, related_name='sunday_plan', on_delete=models.CASCADE, default=None)

    def get_shop_list_divided_by_days(self):
        shop_list = {}
        for field in self._meta.get_fields():
            if field.name in ["id", "diet_name"]:
                continue
            day_receipts = self.__getattribute__(field.name)
            shop_list.update({field.name: day_receipts.get_shop_list()})
        return shop_list

    def get_shop_list(self):
        shop_list = []
        for ingredient in self.get_all_ingredients():
            if self._if_ingredient_with_measurement_exist(ingredient, shop_list):
                new_shop_list = self._get_updated_shop_list(ingredient, shop_list)
                ## currently I have no idea how do it better
                shop_list = new_shop_list
            else:
                shop_list.append(ingredient)
        sorted_shop_list = sorted(shop_list, key=lambda k: k['name'])
        return sorted_shop_list

    def get_all_ingredients(self) -> List[Dict]:
        all_ingredients = []
        for field in self._meta.get_fields():
            if field.name in ["id", "diet_name"]:
                continue
            day_receipts = self.__getattribute__(field.name)
            all_ingredients.extend(day_receipts.get_shop_list())
        return all_ingredients

    def _get_updated_shop_list(self, checked, shop_list: List[Dict]):
        new_shop_list = []
        for i in shop_list:
            if i["name"] == checked["name"] and i["measurement"] == checked["measurement"]:
                new_quantity = checked["quantity"] + i["quantity"]
                new_shop_list.append(
                    {"name": i["name"], "measurement": i["measurement"], "quantity": new_quantity})
            else:
                new_shop_list.append(i)
        return new_shop_list

    def _if_ingredient_with_measurement_exist(self, checked, shop_list: List[Dict]):
        for i in shop_list:
            if i["name"] == checked["name"] and i["measurement"] == checked["measurement"]:
                return True
        return False
