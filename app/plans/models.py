from itertools import groupby

from django.db import models
from recipes.models import Recipe
from collections import defaultdict
from typing import List, Dict
from operator import itemgetter


class DayPlan(models.Model):
    name = models.CharField(default="autogenerated", max_length=100)
    breakfast = models.ForeignKey(Recipe, related_name='receipt_component_breakfast', on_delete=models.CASCADE,
                                  default=None)
    lunch = models.ForeignKey(Recipe, related_name='receipt_component_lunch', on_delete=models.CASCADE, default=None)
    dinner = models.ForeignKey(Recipe, related_name='receipt_component_dinner', on_delete=models.CASCADE, default=None)

    def get_shop_list_divided_by_meal(self):
        shop_list_by_meals = defaultdict(list)
        for meal_name, meal in [("breakfast", self.breakfast), ('lunch', self.lunch), ("dinner", self.dinner)]:
            ingredients = []
            for receipt_component in meal.recipeingredient_set.all():
                ingredient_details = {
                    "name": receipt_component.component.name,
                    "measurement": receipt_component.measurement,
                    "quantity": receipt_component.quantity}
                ingredients.append(ingredient_details)
            shop_list_by_meals.update({meal_name: ingredients})
        return shop_list_by_meals

    def get_shop_list_divided_by_types(self):
        shop_list = defaultdict(list)
        day_ingredients = self.get_all_ingredients_details()
        sorted_by_type = sorted(day_ingredients, key=itemgetter('type'))
        for type_, ingredients in groupby(sorted_by_type, key=itemgetter('type')):
            for name, ingredients_ in groupby(sorted(ingredients, key=itemgetter('name')), key=itemgetter('name')):
                for measurement, ingredients__ in self.group_by_measurement(ingredients_):
                    quantity = sum(x["quantity"] for x in ingredients__)
                    new_type_ingredients = [{'name': name, 'measurement': measurement, 'quantity': quantity}]
                    if previous_ingredients := shop_list[type_]:
                        new_type_ingredients.extend(previous_ingredients)
                    shop_list.update({type_: new_type_ingredients})
        return shop_list

    def group_by_measurement(self, ingredients):
        sorted_by_measurement = sorted(ingredients, key=itemgetter('measurement'))
        return groupby(sorted_by_measurement, key=itemgetter('measurement'))

    def get_all_ingredients_details(self):
        for meal in (self.breakfast, self.lunch, self.dinner):
            for receipt_component in meal.recipeingredient_set.all():
                if not receipt_component.component.types:
                    type_ = "unknown"
                else:
                    type_ = receipt_component.component.types[0]
                yield {
                    "name": receipt_component.component.name,
                    "measurement": receipt_component.measurement,
                    "quantity": receipt_component.quantity,
                    "type": type_}

    def __str__(self):
        return f"{self.name}: {self.breakfast.name} AND {self.lunch.name} AND {self.dinner.name}"


class WeeklyPlan(models.Model):
    DIET = [
        ("AIP", "AIP"),
        ("NORMAL", "NORMAL")
    ]
    diet_name = models.CharField(max_length=6, choices=DIET, default="AIP")
    monday = models.ForeignKey(DayPlan, related_name='monday_plan', on_delete=models.CASCADE, default=None)
    tuesday = models.ForeignKey(DayPlan, related_name='tuesday_plan', on_delete=models.CASCADE, default=None)
    wednesday = models.ForeignKey(DayPlan, related_name='wednesday_plan', on_delete=models.CASCADE, default=None)
    thursday = models.ForeignKey(DayPlan, related_name='thursday_plan', on_delete=models.CASCADE, default=None)
    friday = models.ForeignKey(DayPlan, related_name='friday_plan', on_delete=models.CASCADE, default=None)
    saturday = models.ForeignKey(DayPlan, related_name='saturday_plan', on_delete=models.CASCADE, default=None)
    sunday = models.ForeignKey(DayPlan, related_name='sunday_plan', on_delete=models.CASCADE, default=None)

    def get_shop_list_divided_by_days(self):
        shop_list = {}
        for field in self._meta.get_fields():
            if field.name in ["id", "diet_name"]:
                continue
            day_receipts = self.__getattribute__(field.name)
            shop_list.update({field.name: day_receipts.get_shop_list()})
        return shop_list

    def get_shop_list(self):
        shop_list = []
        for ingredient in self.get_all_ingredients():
            if self._if_ingredient_with_measurement_exist(ingredient, shop_list):
                new_shop_list = self._get_updated_shop_list(ingredient, shop_list)
                ## currently I have no idea how do it better
                shop_list = new_shop_list
            else:
                shop_list.append(ingredient)
        sorted_shop_list = sorted(shop_list, key=lambda k: k['name'])
        return sorted_shop_list

    def get_all_ingredients(self) -> List[Dict]:
        all_ingredients = []
        for field in self._meta.get_fields():
            if field.name in ["id", "diet_name"]:
                continue
            day_receipts = self.__getattribute__(field.name)
            all_ingredients.extend(day_receipts.get_all_ingredients_details())
        return all_ingredients

    def _get_updated_shop_list(self, checked, shop_list: List[Dict]):
        new_shop_list = []
        for i in shop_list:
            if i["name"] == checked["name"] and i["measurement"] == checked["measurement"]:
                new_quantity = checked["quantity"] + i["quantity"]
                new_shop_list.append(
                    {"name": i["name"], "measurement": i["measurement"], "quantity": new_quantity})
            else:
                new_shop_list.append(i)
        return new_shop_list

    def get_shop_list_divided_by_types(self):
        shop_list = defaultdict(list)
        day_ingredients = self.get_all_ingredients()
        sorted_by_type = sorted(day_ingredients, key=itemgetter('type'))
        for type_, ingredients in groupby(sorted_by_type, key=itemgetter('type')):
            for name, ingredients_ in groupby(sorted(ingredients, key=itemgetter('name')), key=itemgetter('name')):
                for measurement, ingredients__ in self.group_by_measurement(ingredients_):
                    quantity = sum(x["quantity"] for x in ingredients__)
                    new_type_ingredients = [{'name': name, 'measurement': measurement, 'quantity': quantity}]
                    if previous_ingredients := shop_list[type_]:
                        new_type_ingredients.extend(previous_ingredients)
                    shop_list.update({type_: new_type_ingredients})
        return shop_list

    def group_by_measurement(self, ingredients):
        sorted_by_measurement = sorted(ingredients, key=itemgetter('measurement'))
        return groupby(sorted_by_measurement, key=itemgetter('measurement'))

    def _if_ingredient_with_measurement_exist(self, checked, shop_list: List[Dict]):
        for i in shop_list:
            if i["name"] == checked["name"] and i["measurement"] == checked["measurement"]:
                return True
        return False
